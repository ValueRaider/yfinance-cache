<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>yfinance_cache.yfc_dat API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yfinance_cache.yfc_dat</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="yfinance_cache.yfc_dat.uniform_prob_lt"><code class="name flex">
<span>def <span class="ident">uniform_prob_lt</span></span>(<span>X, Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="yfinance_cache.yfc_dat.AmbiguousComparisonException"><code class="flex name class">
<span>class <span class="ident">AmbiguousComparisonException</span></span>
<span>(</span><span>value1, value2, operation, true_prob=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmbiguousComparisonException(Exception):
    def __init__(self, value1, value2, operation, true_prob=None):
        if not isinstance(operation, str):
            raise TypeError(f&#34;operation must be a string not {type(operation)}&#34;)
        if true_prob is not None and not isinstance(true_prob, (int, float)):
            raise TypeError(f&#34;true_prob must be numeric not {type(true_prob)}&#34;)

        self.value1 = value1
        self.value2 = value2
        self.operation = operation
        self.true_prob = true_prob

    def __str__(self):
        msg = f&#34;Ambiguous whether {self.value1} {self.operation} {self.value2}&#34;
        if self.true_prob is not None:
            msg += f&#34; (true with probability {self.true_prob*100:.1f}%)&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="yfinance_cache.yfc_dat.ComparableRelativedelta"><code class="flex name class">
<span>class <span class="ident">ComparableRelativedelta</span></span>
<span>(</span><span>dt1=None, dt2=None, years=0, months=0, days=0, leapdays=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0, year=None, month=None, day=None, weekday=None, yearday=None, nlyearday=None, hour=None, minute=None, second=None, microsecond=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The relativedelta type is designed to be applied to an existing datetime and
can replace specific components of that datetime, or represents an interval
of time.</p>
<p>It is based on the specification of the excellent work done by M.-A. Lemburg
in his
<code>mx.DateTime &lt;https://www.egenix.com/products/python/mxBase/mxDateTime/&gt;</code>_ extension.
However, notice that this type does <em>NOT</em> implement the same algorithm as
his work. Do <em>NOT</em> expect it to behave like mx.DateTime's counterpart.</p>
<p>There are two different ways to build a relativedelta instance. The
first one is passing it two date/datetime classes::</p>
<pre><code>relativedelta(datetime1, datetime2)
</code></pre>
<p>The second one is passing it any number of the following keyword arguments::</p>
<pre><code>relativedelta(arg1=x,arg2=y,arg3=z...)

year, month, day, hour, minute, second, microsecond:
    Absolute information (argument is singular); adding or subtracting a
    relativedelta with absolute information does not perform an arithmetic
    operation, but rather REPLACES the corresponding value in the
    original datetime with the value(s) in relativedelta.

years, months, weeks, days, hours, minutes, seconds, microseconds:
    Relative information, may be negative (argument is plural); adding
    or subtracting a relativedelta with relative information performs
    the corresponding arithmetic operation on the original datetime value
    with the information in the relativedelta.

weekday: 
    One of the weekday instances (MO, TU, etc) available in the
    relativedelta module. These instances may receive a parameter N,
    specifying the Nth weekday, which could be positive or negative
    (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
    +1. You can also use an integer, where 0=MO. This argument is always
    relative e.g. if the calculated date is already Monday, using MO(1)
    or MO(-1) won't change the day. To effectively make it absolute, use
    it in combination with the day argument (e.g. day=1, MO(1) for first
    Monday of the month).

leapdays:
    Will add given days to the date found, if year is a leap
    year, and the date found is post 28 of february.

yearday, nlyearday:
    Set the yearday or the non-leap year day (jump leap days).
    These are converted to day/month/leapdays information.
</code></pre>
<p>There are relative and absolute forms of the keyword
arguments. The plural is relative, and the singular is
absolute. For each argument in the order below, the absolute form
is applied first (by setting each attribute to that value) and
then the relative form (by adding the value to the attribute).</p>
<p>The order of attributes considered when this relativedelta is
added to a datetime is:</p>
<ol>
<li>Year</li>
<li>Month</li>
<li>Day</li>
<li>Hours</li>
<li>Minutes</li>
<li>Seconds</li>
<li>Microseconds</li>
</ol>
<p>Finally, weekday is applied, using the rule described above.</p>
<p>For example</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from dateutil.relativedelta import relativedelta, MO
&gt;&gt;&gt; dt = datetime(2018, 4, 9, 13, 37, 0)
&gt;&gt;&gt; delta = relativedelta(hours=25, day=1, weekday=MO(1))
&gt;&gt;&gt; dt + delta
datetime.datetime(2018, 4, 2, 14, 37)
</code></pre>
<p>First, the day is set to 1 (the first of the month), then 25 hours
are added, to get to the 2nd day and 14th hour, finally the
weekday is applied, but since the 2nd is already a Monday there is
no effect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComparableRelativedelta(relativedelta):
    def _have_same_attributes(self, other):
        attrs = [&#39;years&#39;, &#39;months&#39;, &#39;days&#39;, &#39;leapdays&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, &#39;microseconds&#39;, &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;weekday&#39;]

        for a in attrs:
            if getattr(self, a, 0) == 0:
                if getattr(other, a, 0) != 0:
                    return False
        return True

    def __str__(self):
        s = &#39;&#39;

        a = &#39;years&#39;
        x = getattr(self, a, 0)
        if x != 0:
            s += f&#39;{x}y&#39;

        a = &#39;months&#39;
        x = getattr(self, a, 0)
        if x != 0:
            s += f&#39;{x}mo&#39;

        a = &#39;days&#39;
        x = getattr(self, a, 0)
        if x != 0:
            s += f&#39;{x}d&#39;

        a = &#39;hours&#39;
        x = getattr(self, a, 0)
        if x != 0:
            s += f&#39;{x}h&#39;

        a = &#39;minutes&#39;
        x = getattr(self, a, 0)
        if x != 0:
            s += f&#39;{x}m&#39;

        return s

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        if isinstance(other, relativedelta):
            attrs = [&#39;years&#39;, &#39;months&#39;, &#39;days&#39;, &#39;leapdays&#39;, &#39;hours&#39;, &#39;minutes&#39;, &#39;seconds&#39;, &#39;microseconds&#39;, &#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;weekday&#39;]
            return all(getattr(self, attr, 0) == getattr(other, attr, 0) for attr in attrs)

        raise NotImplementedError(f&#39;Not implemented ComparableRelativedelta={self} == {type(other)}={other}&#39;)

    def __lt__(self, other):
        if isinstance(other, (TimedeltaEstimate, TimedeltaRangeEstimate)):
            return other.__gt__(self)

        elif isinstance(other, (relativedelta, timedelta)):
            reference_date = date(2000, 1, 1)
            result_date_self = reference_date + self
            result_date_other = reference_date + other

            if not self._have_same_attributes(other):
                if abs(result_date_self - result_date_other) &lt; timedelta(days=7):
                    raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;)

            return result_date_self &lt; result_date_other

        raise NotImplementedError(f&#39;Not implemented ComparableRelativedelta={self} &lt; {type(other)}={other}&#39;)

    def __le__(self, other):
        return self &lt; other

    def __gt__(self, other):
        if isinstance(other, (TimedeltaEstimate, TimedeltaRangeEstimate)):
            return other.__lt__(self)

        elif isinstance(other, (relativedelta, timedelta)):
            reference_date = date(2000, 1, 1)
            result_date_self = reference_date + self
            result_date_other = reference_date + other

            if not self._have_same_attributes(other):
                if abs(result_date_self - result_date_other) &lt; timedelta(days=7):
                    raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;)

            return result_date_self &gt; result_date_other
        raise NotImplementedError(f&#39;Not implemented ComparableRelativedelta={self} &gt; {type(other)}={other}&#39;)

    def __ge__(self, other):
        return self &gt; other</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>dateutil.relativedelta.relativedelta</li>
</ul>
</dd>
<dt id="yfinance_cache.yfc_dat.Confidence"><code class="flex name class">
<span>class <span class="ident">Confidence</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum where members are also (and must be) ints</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Confidence(IntEnum):
    Low = 0
    Medium = 1
    High = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.Confidence.High"><code class="name">var <span class="ident">High</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Confidence.Low"><code class="name">var <span class="ident">Low</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Confidence.Medium"><code class="name">var <span class="ident">Medium</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate"><code class="flex name class">
<span>class <span class="ident">DateEstimate</span></span>
<span>(</span><span>dt, confidence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateEstimate():
    def __init__(self, dt, confidence):
        if not isinstance(confidence, Confidence):
            raise Exception(&#34;&#39;confidence&#39; must be a &#39;Confidence&#39; object, not {0}&#34;.format(type(confidence)))
        if isinstance(dt, (datetime, pd.Timestamp)) or not isinstance(dt, (date, DateEstimate)):
            raise Exception(&#34;&#39;dt&#39; must be a &#39;date&#39; object or None, not {0}&#34;.format(type(dt)))
        if isinstance(dt, DateEstimate):
            self.date = dt.date
            self.confidence = min(dt.confidence, confidence)
        else:
            self.date = dt
            self.confidence = confidence
        self.uncertainty = confidence_to_buffer[confidence]

    def copy(self):
        return DateEstimate(self.date, self.confidence)

    def __str__(self):
        s = f&#34;DateEstimate {self.date} (conf={self.confidence}/2)&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def prob_lt(self, other):
        if isinstance(other, date):
            if self.date + self.uncertainty &lt; other:
                return 1.0
            elif other &lt;= self.date - self.uncertainty:
                return 0.0
            return uniform_prob_lt((self.date-self.uncertainty, self.date+self.uncertainty), other)
        elif isinstance(other, DateEstimate):
            if self.date + self.uncertainty &lt; other.date - other.uncertainty:
                return 1.0
            elif other.date + other.uncertainty &lt;= self.date - self.uncertainty:
                return 0.0
            return uniform_prob_lt((self.date-self.uncertainty, self.date+self.uncertainty), 
                                  (other.date-other.uncertainty, other.date+other.uncertainty))
        elif isinstance(other, DateRange):
            p = uniform_prob_lt((self.date-self.uncertainty, self.date+self.uncertainty), 
                               (other.start, other.end))
            return p
        elif isinstance(other, DateRangeEstimate):
            return other.__ge__(self)

        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other

    def __abs__(self):
        raise NotImplementedError(f&#39;Not implemented {self} abs&#39;)

    def __eq__(self, other):
        if isinstance(other, DateEstimate):
            return self.date == other.date and self.confidence == other.confidence
        elif isinstance(other, date):
            if self.isclose(other):
                raise AmbiguousComparisonException(self, other, &#39;==&#39;)
            else:
                return False
        raise NotImplementedError(f&#39;Not implemented {self} == {type(other)}={other}&#39;)

    def isclose(self, other):
        if isinstance(other, DateEstimate):
            return abs(self.date - other.date) &lt;= min(self.uncertainty, other.uncertainty)
        else:
            return abs(self.date - other) &lt;= self.uncertainty
        raise NotImplementedError(f&#39;Not implemented {self} is-close-to {type(other)}={other}&#39;)

    def __iadd__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            self.date += other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} += {type(other)}={other}&#39;)

    def __add__(self, other):
        if isinstance(other, TimedeltaEstimate):
            return DateEstimate(self.date+other.td, min(self.confidence, other.confidence))
        elif isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            return DateEstimate(self.date+other, self.confidence)
        elif isinstance(other, TimedeltaRange):
            return DateRangeEstimate(self.date + other.td1, self.date + other.td2, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __radd__(self, other):
        return self.__add__(other)

    def __isub__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            self.date -= other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} -= {type(other)}={other}&#39;)

    def __sub__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            return DateEstimate(self.date-other, self.confidence)
        elif isinstance(other, TimedeltaEstimate):
            return DateEstimate(self.date-other.td, min(self.confidence, other.confidence))
        elif isinstance(other, DateEstimate):
            td = self.date - other.date
            c0 = self.confidence
            c1 = other.confidence
            return TimedeltaEstimate(td, min(c0, c1))
        elif isinstance(other, date):
            return TimedeltaEstimate(self.date-other, self.confidence)
        elif isinstance(other, DateRange):
            return TimedeltaRangeEstimate(self.date - other.start, self.date - other.end, self.confidence)
        elif isinstance(other, DateRangeEstimate):
            return TimedeltaRangeEstimate(self.date - other.start, self.date - other.end, min(self.confidence, other.confidence))
        raise NotImplementedError(f&#39;Not implemented {self} - {type(other)}={other}&#39;)

    def __rsub__(self, other):
        if isinstance(other, DateEstimate):
            return other - self
        elif isinstance(other, date):
            return TimedeltaEstimate(other - self.date, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} rsub {type(other)}={other}&#39;)

    def __neg__(self):
        raise NotImplementedError(f&#39;Not implemented {self} negate&#39;)

    def __invert__(self):
        raise NotImplementedError(f&#39;Not implemented {self} invert&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateEstimate.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateEstimate.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.DateInterval"><code class="flex name class">
<span>class <span class="ident">DateInterval</span></span>
<span>(</span><span>left, right, closed=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateInterval:
    def __init__(self, left, right, closed=None):
        if not isinstance(left, date) or isinstance(left, datetime):
            raise TypeError(&#34;&#39;left&#39; must be date object not datetime&#34;)

        self.left = left
        self.right = right

        if closed is None:
            self.closed = None
        else:
            if closed not in [&#34;left&#34;, &#34;right&#34;]:
                raise Exception(&#34;closed must be left or right&#34;)
            self.closed = closed

    def __eq__(self, other):
        return self.left == other.left and self.right == other.right and self.closed == other.closed

    def __str__(self):
        s = &#34;&#34;
        if self.closed == &#34;left&#34;:
            s += &#39;[&#39;
        else:
            s += &#39;(&#39;
        s += str(self.left) + &#39;, &#39; + str(self.right)
        if self.closed == &#34;right&#34;:
            s += &#39;]&#39;
        else:
            s += &#39;)&#39;
        return s

    def __repr__(self):
        return self.__str__()</code></pre>
</details>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex"><code class="flex name class">
<span>class <span class="ident">DateIntervalIndex</span></span>
<span>(</span><span>intervals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateIntervalIndex:
    def __init__(self, intervals):
        if not isinstance(intervals, (list, np.ndarray, pd.Series)):
            raise TypeError(f&#34;&#39;intervals&#39; must be iterable not &#39;{type(intervals)}&#39;&#34;)
        if not isinstance(intervals, np.ndarray):
            self.array = np.array(intervals)
        else:
            self.array = intervals

        self._left = np.array([x.left for x in self.array])
        self._right = np.array([x.right for x in self.array])
        self._right_inc = self._right - timedelta(days=1)

    @classmethod
    def from_arrays(cls, left, right, closed=None):
        if len(left) != len(right):
            raise Exception(&#34;left and right must be equal length&#34;)
        if isinstance(left, pd.Series):
            intervals = [DateInterval(left.iloc[i], right.iloc[i], closed) for i in range(len(left))]
        else:
            intervals = [DateInterval(left[i], right[i], closed) for i in range(len(left))]
        return cls(intervals)

    @property
    def left(self):
        return self._left

    @property
    def right(self):
        return self._right

    @property
    def shape(self):
        return (len(self.array), 2)

    @property
    def empty(self):
        return self.shape[0] == 0

    def __len__(self):
        return self.shape[0]

    def sort_values(self):
        return DateIntervalIndex(self.array[np.argsort(self._left)])

    def get_indexer(self, values):
        idx_right = np.searchsorted(self._right_inc, values)

        idx_left = np.searchsorted(self._left, values, side=&#34;right&#34;)
        idx_left -= 1

        f_match = idx_right == idx_left

        idx = idx_left
        idx[~f_match] = -1
        return idx

    def __getitem__(self, i):
        v = self.array[i]
        if isinstance(v, np.ndarray):
            v = DateIntervalIndex(v)
        return v

    def __setitem__(self, i, v):
        raise Exception(&#34;immutable&#34;)

    def __eq__(self, other):
        if not isinstance(other, DateIntervalIndex):
            return False
        if len(self.array) != len(other.array):
            return False
        return np.equal(self.array, other.array)

    def equals(self, other):
        e = self == other
        if isinstance(e, np.ndarray):
            e = e.all()
        return e

    def __str__(self):
        s = &#34;DateIntervalIndex([ &#34;
        for x in self.array:
            s += x.__str__() + &#34; , &#34;
        s += &#34;])&#34;
        return s

    def __repr__(self):
        return self.__str__()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.from_arrays"><code class="name flex">
<span>def <span class="ident">from_arrays</span></span>(<span>left, right, closed=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.empty"><code class="name">prop <span class="ident">empty</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def empty(self):
    return self.shape[0] == 0</code></pre>
</details>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.left"><code class="name">prop <span class="ident">left</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def left(self):
    return self._left</code></pre>
</details>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.right"><code class="name">prop <span class="ident">right</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def right(self):
    return self._right</code></pre>
</details>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.shape"><code class="name">prop <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return (len(self.array), 2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.get_indexer"><code class="name flex">
<span>def <span class="ident">get_indexer</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateIntervalIndex.sort_values"><code class="name flex">
<span>def <span class="ident">sort_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange"><code class="flex name class">
<span>class <span class="ident">DateRange</span></span>
<span>(</span><span>start, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateRange():
    def __init__(self, start, end):
        if (start is not None) and not isinstance(start, date):
            raise Exception(&#34;&#39;start&#39; must be a &#39;date&#39; object or None, not {0}&#34;.format(type(start)))
        if (end is not None) and not isinstance(end, date):
            raise Exception(&#34;&#39;end&#39; must be a &#39;date&#39; object or None, not {0}&#34;.format(type(end)))
        self.start = start
        self.end = end

    def copy(self):
        return DateRange(self.start, self.end)

    def __str__(self):
        s = f&#34;DateRange {self.start} -&gt; {self.end}&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def __abs__(self):
        raise NotImplementedError(f&#39;Not implemented {self} abs&#39;)

    def __eq__(self, other):
        if isinstance(other, DateRange):
            return self.start == other.start and self.end == other.end
        raise NotImplementedError(f&#39;Not implemented {self} == {type(other)}={other}&#39;)

    def isclose(self, other):
        if isinstance(other, DateRange):
            return (other.start &lt;= self.end) and (self.start &lt;= other.end)
        elif isinstance(other, date):
            return self.start &lt;= other and other &lt;= self.end
        elif isinstance(other, DateEstimate):
            return self.start &lt;= other.date+other.uncertainty and other.date-other.uncertainty &lt;= self.end
        elif isinstance(other, DateRangeEstimate):
            return other.isclose(self)
        raise NotImplementedError(f&#39;Not implemented {self} is-close-to {type(other)}={other}&#39;)

    def prob_lt(self, other):
        if isinstance(other, date):
            if self.start &gt;= other:
                return 0.0
            elif self.end &lt; other:
                return 1.0
            else:
                return uniform_prob_lt((self.start, self.end), other)
        elif isinstance(other, DateRange):
            if other.end &lt;= self.start:
                return 0.0
            elif self.end &lt; other.start:
                return 1.0
            else:
                return uniform_prob_lt((self.start, self.end), (other.start, other.end))
        elif isinstance(other, DateEstimate):
            return other.prob_gt(self)
        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other

    def __iadd__(self, other):
        if isinstance(other, (timedelta, pd.Timedelta)):
            self.start += other
            self.end += other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} += {type(other)}={other}&#39;)

    def __add__(self, other):
        if isinstance(other, timedelta):
            return DateRange(self.start + other, self.end + other)
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __radd__(self, other):
        raise NotImplementedError(f&#39;Not implemented {self} radd {type(other)}={other}&#39;)

    def __isub__(self, other):
        raise NotImplementedError(f&#39;Not implemented {self} -= {type(other)}={other}&#39;)

    def __sub__(self, other):
        if isinstance(other, date):
            return TimedeltaRange(self.start - other, self.end - other)
        elif isinstance(other, DateRange):
            return TimedeltaRange(self.start - other.end, self.end - other.start)
        elif isinstance(other, DateEstimate):
            return TimedeltaRangeEstimate(self.start - other.date, self.end - other.date, other.confidence)
        elif isinstance(other, timedelta):
            return DateRange(self.start - other, self.end - other)
        raise NotImplementedError(f&#39;Not implemented {self} - {type(other)}={other}&#39;)

    def __rsub__(self, other):
        if isinstance(other, date):
            return TimedeltaRange(other - self.start, other - self.end)
        raise NotImplementedError(f&#39;Not implemented {self} rsub {type(other)}={other}&#39;)

    def __neg__(self):
        raise NotImplementedError(f&#39;Not implemented {self} negate&#39;)

    def __invert__(self):
        raise NotImplementedError(f&#39;Not implemented {self} invert&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateRange.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRange.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate"><code class="flex name class">
<span>class <span class="ident">DateRangeEstimate</span></span>
<span>(</span><span>start, end, confidence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateRangeEstimate():
    def __init__(self, start, end, confidence):
        if (start is not None) and not isinstance(start, date):
            raise Exception(&#34;&#39;start&#39; must be a &#39;date&#39; object or None, not {0}&#34;.format(type(start)))
        if (end is not None) and not isinstance(end, date):
            raise Exception(&#34;&#39;end&#39; must be a &#39;date&#39; object or None, not {0}&#34;.format(type(end)))
        if not isinstance(confidence, Confidence):
            raise Exception(&#34;&#39;confidence&#39; must be a &#39;Confidence&#39; object, not {0}&#34;.format(type(confidence)))
        self.start = start
        self.end = end
        self.confidence = confidence
        self.uncertainty = confidence_to_buffer[confidence]

    def copy(self):
        return DateRangeEstimate(self.start, self.end, self.confidence)

    def __str__(self):
        s = f&#34;DateRangeEstimate {self.start} -&gt; {self.end} (conf={self.confidence}/2)&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def __abs__(self):
        raise NotImplementedError(f&#39;Not implemented {self} abs&#39;)

    def __eq__(self, other):
        if isinstance(other, DateRangeEstimate):
            return self.start == other.start and self.end == other.end and self.confidence == other.confidence
        raise NotImplementedError(f&#39;Not implemented {self} == {type(other)}={other}&#39;)

    def isclose(self, other):
        if isinstance(other, date):
            if (self.start - self.uncertainty) &lt;= other and other &lt;= (self.end + self.uncertainty):
                return True
            else:
                return False
        elif isinstance(other, DateRange):
            if ((self.start - self.uncertainty) &lt;= other.start and other.start &lt;= (self.end + self.uncertainty)) or\
               ((self.start - self.uncertainty) &lt;= other.end and other.end &lt;= (self.end + self.uncertainty)):
                return True
            else:
                return False
        elif isinstance(other, DateEstimate):
            if (self.start - self.uncertainty) &lt;= (other.date+other.uncertainty) and (self.end + self.uncertainty) &gt;= (other.date-other.uncertainty):
                return True
            else:
                return False
        elif isinstance(other, DateRangeEstimate):
            self_start_min = self.start - self.uncertainty
            self_end_max   = self.end + self.uncertainty
            other_start_min = other.start - other.uncertainty
            other_end_max   = other.end + other.uncertainty
            return (other_start_min &lt;= self_end_max) and (self_start_min &lt;= other_end_max)

        raise NotImplementedError(f&#39;Not implemented {self} is-close-to {type(other)}={other}&#39;)

    def __neg__(self):
        raise NotImplementedError(f&#39;Not implemented {self} negate&#39;)

    def __invert__(self):
        raise NotImplementedError(f&#39;Not implemented {self} invert&#39;)

    def __iadd__(self, other):
        if isinstance(other, (timedelta, pd.Timedelta)):
            self.start += other
            self.end += other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} += {type(other)}={other}&#39;)

    def __add__(self, other):
        if isinstance(other, timedelta):
            return DateRangeEstimate(self.start + other, self.end + other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __radd__(self, other):
        raise NotImplementedError(f&#39;Not implemented {self} radd {type(other)}={other}&#39;)

    def __isub__(self, other):
        raise NotImplementedError(f&#39;Not implemented {self} -= {type(other)}={other}&#39;)

    def __sub__(self, other):
        if isinstance(other, date):
            return TimedeltaRangeEstimate(self.start - other, self.end - other, self.confidence)
        elif isinstance(other, DateEstimate):
            conf = min(self.confidence, other.confidence)
            return TimedeltaRangeEstimate(self.start - other.date, self.end - other.date, conf)
        elif isinstance(other, DateRange):
            return TimedeltaRangeEstimate(self.start - other.start, self.end - other.end, self.confidence)
        elif isinstance(other, DateRangeEstimate):
            conf = min(self.confidence, other.confidence)
            return TimedeltaRangeEstimate(self.start - other.start, self.end - other.end, conf)
        raise NotImplementedError(f&#39;Not implemented {self} - {type(other)}={other}&#39;)

    def __rsub__(self, other):
        return -self.__sub__(other)

    def prob_lt(self, other):
        if isinstance(other, date):
            if self.end + self.uncertainty &lt; other:
                return 1.0
            elif other &lt;= self.start - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.start-self.uncertainty, self.end+self.uncertainty),
                                      other)

        elif isinstance(other, DateEstimate):
            if self.end + self.uncertainty &lt; other.date - other.uncertainty:
                return 1.0
            elif other.date + other.uncertainty &lt;= self.start - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.start-self.uncertainty, self.end+self.uncertainty),
                                      (other.date-other.uncertainty, other.date+other.uncertainty))

        elif isinstance(other, DateRangeEstimate):
            if self.end + self.uncertainty &lt; other.start - other.uncertainty:
                return 1.0
            elif other.end + other.uncertainty &lt;= self.start - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.start-self.uncertainty, self.end+self.uncertainty),
                                      (other.start-other.uncertainty, other.end+other.uncertainty))

        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.DateRangeEstimate.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.Financials"><code class="flex name class">
<span>class <span class="ident">Financials</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Financials(Enum):
    IncomeStmt = 0
    BalanceSheet = 1
    CashFlow = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.Financials.BalanceSheet"><code class="name">var <span class="ident">BalanceSheet</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Financials.CashFlow"><code class="name">var <span class="ident">CashFlow</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Financials.IncomeStmt"><code class="name">var <span class="ident">IncomeStmt</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval"><code class="flex name class">
<span>class <span class="ident">Interval</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interval(Enum):
    Week = 5
    Days1 = 10
    Hours1 = 20
    Mins90 = 21
    Mins60 = 22
    Mins30 = 23
    Mins15 = 24
    Mins5 = 25
    Mins2 = 26
    Mins1 = 27</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.Interval.Days1"><code class="name">var <span class="ident">Days1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Hours1"><code class="name">var <span class="ident">Hours1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins1"><code class="name">var <span class="ident">Mins1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins15"><code class="name">var <span class="ident">Mins15</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins2"><code class="name">var <span class="ident">Mins2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins30"><code class="name">var <span class="ident">Mins30</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins5"><code class="name">var <span class="ident">Mins5</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins60"><code class="name">var <span class="ident">Mins60</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Mins90"><code class="name">var <span class="ident">Mins90</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Interval.Week"><code class="name">var <span class="ident">Week</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.NoIntervalsInRangeException"><code class="flex name class">
<span>class <span class="ident">NoIntervalsInRangeException</span></span>
<span>(</span><span>interval, start_dt, end_dt, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoIntervalsInRangeException(Exception):
    def __init__(self, interval, start_dt, end_dt, *args):
        super().__init__(args)
        self.interval = interval
        self.start_dt = start_dt
        self.end_dt = end_dt

    def __str__(self):
        return (&#34;No {} intervals found between {}-&gt;{}&#34;.format(self.interval, self.start_dt, self.end_dt))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="yfinance_cache.yfc_dat.NoPriceDataInRangeException"><code class="flex name class">
<span>class <span class="ident">NoPriceDataInRangeException</span></span>
<span>(</span><span>tkr, interval, start_dt, end_dt, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoPriceDataInRangeException(Exception):
    def __init__(self, tkr, interval, start_dt, end_dt, *args):
        super().__init__(args)
        self.tkr = tkr
        self.interval = interval
        self.start_dt = start_dt
        self.end_dt = end_dt

    def __str__(self):
        return (&#34;No {}-price data fetched for ticker {} between dates {} -&gt; {}&#34;.format(self.interval, self.tkr, self.start_dt, self.end_dt))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="yfinance_cache.yfc_dat.Period"><code class="flex name class">
<span>class <span class="ident">Period</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Period(Enum):
    Days1 = 0
    Days5 = 1
    Months1 = 10
    Months3 = 11
    Months6 = 12
    Years1 = 20
    Years2 = 21
    Years5 = 22
    Ytd = 24
    Max = 30</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.Period.Days1"><code class="name">var <span class="ident">Days1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Days5"><code class="name">var <span class="ident">Days5</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Max"><code class="name">var <span class="ident">Max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Months1"><code class="name">var <span class="ident">Months1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Months3"><code class="name">var <span class="ident">Months3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Months6"><code class="name">var <span class="ident">Months6</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Years1"><code class="name">var <span class="ident">Years1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Years2"><code class="name">var <span class="ident">Years2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Years5"><code class="name">var <span class="ident">Years5</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.Period.Ytd"><code class="name">var <span class="ident">Ytd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.ReportingPeriod"><code class="flex name class">
<span>class <span class="ident">ReportingPeriod</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReportingPeriod(Enum):
    Interim = 0
    Full = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.ReportingPeriod.Full"><code class="name">var <span class="ident">Full</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.ReportingPeriod.Interim"><code class="name">var <span class="ident">Interim</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate"><code class="flex name class">
<span>class <span class="ident">TimedeltaEstimate</span></span>
<span>(</span><span>td, confidence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimedeltaEstimate():
    def __init__(self, td, confidence):
        if not isinstance(confidence, Confidence):
            raise Exception(&#34;&#39;confidence&#39; must be a &#39;Confidence&#39; object, not {0}&#34;.format(type(confidence)))
        if not isinstance(td, (timedelta, pd.Timedelta, ComparableRelativedelta)):
            raise Exception(&#34;&#39;td&#39; must be a &#39;timedelta&#39; object or None, not {0}&#34;.format(type(td)))
        if isinstance(td, ComparableRelativedelta) and confidence != Confidence.High:
            td = timedelta(days=td.years*365 +td.months*30 +td.days)
        self.td = td
        self.confidence = confidence
        self.uncertainty = confidence_to_buffer[confidence]

    def copy(self):
        return TimedeltaEstimate(self.td, self.confidence)

    def __str__(self):
        tdstr = &#39;&#39;
        if self.td.days != 0:
            tdstr += f&#39;{self.td.days}d&#39;
        s = f&#34;{tdstr} (conf={self.confidence}/2)&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def __abs__(self):
        return TimedeltaEstimate(abs(self.td), self.confidence)

    def __neg__(self):
        return TimedeltaEstimate(-self.td, self.confidence)

    def __eq__(self, other):
        if isinstance(other, TimedeltaEstimate):
            return self.td == other.td and self.confidence == other.confidence
        raise NotImplementedError(f&#39;Not implemented {self} == {type(other)}={other}&#39;)

    def isclose(self, other):
        if isinstance(other, TimedeltaEstimate):
            # return abs(self.td - other.td) &lt;= max(self.uncertainty, other.uncertainty)
            return abs(self.td - other.td) &lt;= (self.uncertainty + other.uncertainty)

        elif isinstance(other, (timedelta, pd.Timedelta, ComparableRelativedelta)):
            return abs(self.td - other) &lt;= self.uncertainty
        
        raise NotImplementedError(f&#39;Not implemented {self} is-close-to {type(other)}={other}&#39;)

    def __iadd__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            self.td += other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} += {type(other)}={other}&#39;)

    def __add__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            return TimedeltaEstimate(self.td + other, self.confidence)
        elif isinstance(other, date):
            return DateEstimate(self.td + other, self.confidence)
        elif isinstance(other, DateEstimate):
            return DateEstimate(self.td + other.date, min(self.confidence, other.confidence))
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        if isinstance(other, (timedelta, relativedelta, ComparableRelativedelta)):
            return TimedeltaEstimate(self.td - other, self.confidence)
        elif isinstance(other, date):
            return DateEstimate(self.td - other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} - {type(other)}={other}&#39;)

    def __rsub__(self, other):
        if isinstance(other, date):
            return DateEstimate(other - self.td, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} rsub {type(other)}={other}&#39;)

    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return TimedeltaEstimate(self.td * other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} * {type(other)}={other}&#39;)

    def __imul__(self, other):
        if isinstance(other, (int, float)):
            self.td *= other
            return self
        raise NotImplementedError(f&#39;Not implemented {self} *= {type(other)}={other}&#39;)

    def prob_lt(self, other):
        if isinstance(other, TimedeltaRangeEstimate):
            return other.prob_gt(self)

        elif isinstance(other, TimedeltaRange):
            if self.td + self.uncertainty &lt; other.td1:
                return 1.0
            elif other.td2 &lt;= self.td - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td-self.uncertainty, self.td+self.uncertainty),
                                      (other.td1, other.td2))

        elif isinstance(other, TimedeltaEstimate):
            if self.td + self.uncertainty &lt; other.td - other.uncertainty:
                return 1.0
            elif other.td + other.uncertainty &lt;= self.td - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td-self.uncertainty, self.td+self.uncertainty),
                                      (other.td-other.uncertainty, other.td+other.uncertainty))

        elif isinstance(other, (relativedelta, timedelta, ComparableRelativedelta)):
            if self.td + self.uncertainty &lt; other:
                return 1.0
            elif other &lt;= self.td - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td-self.uncertainty, self.td+self.uncertainty),
                                       other)

        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other

    def __mod__(self, other):
        if isinstance(other, timedelta):
            if self.td &lt; timedelta(0):
                raise NotImplementedError(&#39;Not implemented modulus of negative TimedeltaEstimate&#39;)
            else:
                td = self.td
                while td &gt; other:
                    td -= other
                return TimedeltaEstimate(td, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} modulus-of {type(other)}={other}&#39;)

    def __truediv__(self, other):
        if isinstance(other, (int, float, np.int64)):
            return TimedeltaEstimate(self.td / other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} / {type(other)}={other}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRange"><code class="flex name class">
<span>class <span class="ident">TimedeltaRange</span></span>
<span>(</span><span>td1, td2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimedeltaRange():
    def __init__(self, td1, td2):
        if (td1 is not None) and not isinstance(td1, (timedelta, pd.Timedelta)):
            raise Exception(&#34;&#39;td1&#39; must be a &#39;timedelta&#39; object or None, not {0}&#34;.format(type(td1)))
        if (td2 is not None) and not isinstance(td2, (timedelta, pd.Timedelta)):
            raise Exception(&#34;&#39;td2&#39; must be a &#39;timedelta&#39; object or None, not {0}&#34;.format(type(td2)))
        if td2 &lt;= td1:
            swap = td1 ; td1 = td2 ; td2 = swap
        self.td1 = td1
        self.td2 = td2

    def __str__(self):
        s = f&#34;TimedeltaRange {self.td1} -&gt; {self.td2}&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def __abs__(self):
        if self.td2 &lt;= timedelta(0):
            tdr = TimedeltaRange(-self.td1, -self.td2)
            return tdr
        elif self.td1 &gt;= timedelta(0):
            return self
        else:
            raise AmbiguousComparisonException(self, None, &#34;abs&#34;)

    def __add__(self, other):
        if isinstance(other, date):
            return DateRange(other+self.td1, other+self.td2)
        elif isinstance(other, DateEstimate):
            return DateRangeEstimate(other.date+self.td1, other.date+self.td2, other.confidence)
        elif isinstance(other, timedelta):
            return TimedeltaRange(self.td1 + other, self.td2 + other)
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __mul__(self, other):
        if isinstance(other, int):
            return TimedeltaRange(self.td1 * other, self.td2 * other)
        raise NotImplementedError(f&#39;Not implemented {self} * {type(other)}={other}&#39;)

    def prob_lt(self, other):
        if isinstance(other, (timedelta, pd.Timedelta, ComparableRelativedelta)):
            if self.td2 &lt; other:
                return 1.0
            else:
                return 0.0
        elif isinstance(other, TimedeltaRange):
            if self.td2 &lt; other.td1:
                return 1.0
            elif other.td2 &lt;= self.td1:
                return 0.0
            else:
                return uniform_prob_lt((self.td1, self.td2), 
                                      (other.td1, other.td2))
        elif isinstance(other, TimedeltaEstimate):
            return other.prob_gt(self)
        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.TimedeltaRange.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRange.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRange.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRange.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate"><code class="flex name class">
<span>class <span class="ident">TimedeltaRangeEstimate</span></span>
<span>(</span><span>td1, td2, confidence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimedeltaRangeEstimate():
    def __init__(self, td1, td2, confidence):
        if not isinstance(confidence, Confidence):
            raise Exception(&#34;&#39;confidence&#39; must be a &#39;Confidence&#39; object, not {0}&#34;.format(type(confidence)))
        if (td1 is not None) and not isinstance(td1, (timedelta, pd.Timedelta)):
            raise Exception(&#34;&#39;td1&#39; must be a &#39;timedelta&#39; object or None, not {0}&#34;.format(type(td1)))
        if (td2 is not None) and not isinstance(td2, (timedelta, pd.Timedelta)):
            raise Exception(&#34;&#39;td2&#39; must be a &#39;timedelta&#39; object or None, not {0}&#34;.format(type(td2)))
        if td2 &lt;= td1:
            swap = td1 ; td1 = td2 ; td2 = swap
        self.td1 = td1
        self.td2 = td2
        self.confidence = confidence
        self.uncertainty = confidence_to_buffer[confidence]

    def __str__(self):
        s = f&#34;TimedeltaRangeEstimate {self.td1} -&gt; {self.td2} (conf={self.confidence}/2)&#34;
        return s

    def __repr__(self):
        return self.__str__()

    def __abs__(self):
        return TimedeltaRangeEstimate(abs(self.td1), abs(self.td2), self.confidence)

    def isclose(self, other):
        raise NotImplementedError(f&#39;Not implemented {self} is-close-to {type(other)}={other}&#39;)

    def __neg__(self):
        return TimedeltaRangeEstimate(-self.td2, -self.td1, self.confidence)

    def __invert__(self):
        raise NotImplementedError(f&#39;Not implemented {self} invert&#39;)

    def __eq__(self, other):
        if isinstance(other, TimedeltaRangeEstimate):
            return self.td1 == other.td1 and self.td2 == other.td2 and self.confidence == other.confidence
        raise NotImplementedError(f&#39;Not implemented {self} == {type(other)}={other}&#39;)

    def __add__(self, other):
        if isinstance(other, date):
            return DateRangeEstimate(self.td1 + other, self.td2 + other, self.confidence)
        elif isinstance(other, DateEstimate):
            return DateRangeEstimate(self.td1 + other.date, self.td2 + other.date, min(self.confidence, other.confidence))
        elif isinstance(other, timedelta):
            return TimedeltaRangeEstimate(self.td1 + other, self.td2 + other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} + {type(other)}={other}&#39;)

    def __mul__(self, other):
        if isinstance(other, int):
            return TimedeltaRangeEstimate(self.td1 * other, self.td2 * other, self.confidence)
        raise NotImplementedError(f&#39;Not implemented {self} * {type(other)}={other}&#39;)

    def prob_lt(self, other):
        if isinstance(other, (timedelta, pd.Timedelta, ComparableRelativedelta)):
            if self.td2 + self.uncertainty &lt; other:
                return 1.0
            elif other &lt;= self.td1 - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td1-self.uncertainty, self.td2+self.uncertainty), 
                                      other)

        elif isinstance(other, TimedeltaEstimate):
            if self.td2 + self.uncertainty &lt; other.td - other.uncertainty:
                return 1.0
            elif other.td + other.uncertainty &lt;= self.td1 - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td1-self.uncertainty, self.td2+self.uncertainty), 
                                      (other.td-other.uncertainty, other.td+other.uncertainty))

        elif isinstance(other, TimedeltaRangeEstimate):
            if self.td2 + self.uncertainty &lt; other.td1 - other.uncertainty:
                return 1.0
            elif other.td2 + other.uncertainty &lt;= self.td1 - self.uncertainty:
                return 0.0
            else:
                return uniform_prob_lt((self.td1-self.uncertainty, self.td2+self.uncertainty), 
                                      (other.td1-other.uncertainty, other.td2+other.uncertainty))

        raise NotImplementedError(f&#39;Not implemented {self} &lt; {type(other)}={other}&#39;)
    def __lt__(self, other):
        x = self.prob_lt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&lt;&#39;, x)
    def prob_gt(self, other):
        return 1.0 - self.prob_lt(other)
    def __gt__(self, other):
        x = self.prob_gt(other)
        if x in [0.0, 1.0]:
            return x == 1.0
        else:
            raise AmbiguousComparisonException(self, other, &#39;&gt;&#39;, x)
    def prob_le(self, other):
        return self.prob_lt(other)
    def __le__(self, other):
        return self &lt; other
    def prob_ge(self, other):
        return self.prob_gt(other)
    def __ge__(self, other):
        return self &gt; other</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_ge"><code class="name flex">
<span>def <span class="ident">prob_ge</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_gt"><code class="name flex">
<span>def <span class="ident">prob_gt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_le"><code class="name flex">
<span>def <span class="ident">prob_le</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_lt"><code class="name flex">
<span>def <span class="ident">prob_lt</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="yfinance_cache.yfc_dat.TimestampOutsideIntervalException"><code class="flex name class">
<span>class <span class="ident">TimestampOutsideIntervalException</span></span>
<span>(</span><span>exchange, interval, ts, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimestampOutsideIntervalException(Exception):
    def __init__(self, exchange, interval, ts, *args):
        super().__init__(args)
        self.exchange = exchange
        self.interval = interval
        self.ts = ts

    def __str__(self):
        return (f&#34;Failed to map &#39;{self.ts}&#39; to &#39;{self.interval}&#39; interval on exchange &#39;{self.exchange}&#39;&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yfinance_cache" href="yfinance_cache.html">yfinance_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.uniform_prob_lt" href="#yfinance_cache.yfc_dat.uniform_prob_lt">uniform_prob_lt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.AmbiguousComparisonException" href="#yfinance_cache.yfc_dat.AmbiguousComparisonException">AmbiguousComparisonException</a></code></h4>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.ComparableRelativedelta" href="#yfinance_cache.yfc_dat.ComparableRelativedelta">ComparableRelativedelta</a></code></h4>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.Confidence" href="#yfinance_cache.yfc_dat.Confidence">Confidence</a></code></h4>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.Confidence.High" href="#yfinance_cache.yfc_dat.Confidence.High">High</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Confidence.Low" href="#yfinance_cache.yfc_dat.Confidence.Low">Low</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Confidence.Medium" href="#yfinance_cache.yfc_dat.Confidence.Medium">Medium</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.DateEstimate" href="#yfinance_cache.yfc_dat.DateEstimate">DateEstimate</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.copy" href="#yfinance_cache.yfc_dat.DateEstimate.copy">copy</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.isclose" href="#yfinance_cache.yfc_dat.DateEstimate.isclose">isclose</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.prob_ge" href="#yfinance_cache.yfc_dat.DateEstimate.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.prob_gt" href="#yfinance_cache.yfc_dat.DateEstimate.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.prob_le" href="#yfinance_cache.yfc_dat.DateEstimate.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateEstimate.prob_lt" href="#yfinance_cache.yfc_dat.DateEstimate.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.DateInterval" href="#yfinance_cache.yfc_dat.DateInterval">DateInterval</a></code></h4>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex" href="#yfinance_cache.yfc_dat.DateIntervalIndex">DateIntervalIndex</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.empty" href="#yfinance_cache.yfc_dat.DateIntervalIndex.empty">empty</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.equals" href="#yfinance_cache.yfc_dat.DateIntervalIndex.equals">equals</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.from_arrays" href="#yfinance_cache.yfc_dat.DateIntervalIndex.from_arrays">from_arrays</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.get_indexer" href="#yfinance_cache.yfc_dat.DateIntervalIndex.get_indexer">get_indexer</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.left" href="#yfinance_cache.yfc_dat.DateIntervalIndex.left">left</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.right" href="#yfinance_cache.yfc_dat.DateIntervalIndex.right">right</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.shape" href="#yfinance_cache.yfc_dat.DateIntervalIndex.shape">shape</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateIntervalIndex.sort_values" href="#yfinance_cache.yfc_dat.DateIntervalIndex.sort_values">sort_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.DateRange" href="#yfinance_cache.yfc_dat.DateRange">DateRange</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.DateRange.copy" href="#yfinance_cache.yfc_dat.DateRange.copy">copy</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRange.isclose" href="#yfinance_cache.yfc_dat.DateRange.isclose">isclose</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRange.prob_ge" href="#yfinance_cache.yfc_dat.DateRange.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRange.prob_gt" href="#yfinance_cache.yfc_dat.DateRange.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRange.prob_le" href="#yfinance_cache.yfc_dat.DateRange.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRange.prob_lt" href="#yfinance_cache.yfc_dat.DateRange.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate" href="#yfinance_cache.yfc_dat.DateRangeEstimate">DateRangeEstimate</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.copy" href="#yfinance_cache.yfc_dat.DateRangeEstimate.copy">copy</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.isclose" href="#yfinance_cache.yfc_dat.DateRangeEstimate.isclose">isclose</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.prob_ge" href="#yfinance_cache.yfc_dat.DateRangeEstimate.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.prob_gt" href="#yfinance_cache.yfc_dat.DateRangeEstimate.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.prob_le" href="#yfinance_cache.yfc_dat.DateRangeEstimate.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.DateRangeEstimate.prob_lt" href="#yfinance_cache.yfc_dat.DateRangeEstimate.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.Financials" href="#yfinance_cache.yfc_dat.Financials">Financials</a></code></h4>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.Financials.BalanceSheet" href="#yfinance_cache.yfc_dat.Financials.BalanceSheet">BalanceSheet</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Financials.CashFlow" href="#yfinance_cache.yfc_dat.Financials.CashFlow">CashFlow</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Financials.IncomeStmt" href="#yfinance_cache.yfc_dat.Financials.IncomeStmt">IncomeStmt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.Interval" href="#yfinance_cache.yfc_dat.Interval">Interval</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.Interval.Days1" href="#yfinance_cache.yfc_dat.Interval.Days1">Days1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Hours1" href="#yfinance_cache.yfc_dat.Interval.Hours1">Hours1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins1" href="#yfinance_cache.yfc_dat.Interval.Mins1">Mins1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins15" href="#yfinance_cache.yfc_dat.Interval.Mins15">Mins15</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins2" href="#yfinance_cache.yfc_dat.Interval.Mins2">Mins2</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins30" href="#yfinance_cache.yfc_dat.Interval.Mins30">Mins30</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins5" href="#yfinance_cache.yfc_dat.Interval.Mins5">Mins5</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins60" href="#yfinance_cache.yfc_dat.Interval.Mins60">Mins60</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Mins90" href="#yfinance_cache.yfc_dat.Interval.Mins90">Mins90</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Interval.Week" href="#yfinance_cache.yfc_dat.Interval.Week">Week</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.NoIntervalsInRangeException" href="#yfinance_cache.yfc_dat.NoIntervalsInRangeException">NoIntervalsInRangeException</a></code></h4>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.NoPriceDataInRangeException" href="#yfinance_cache.yfc_dat.NoPriceDataInRangeException">NoPriceDataInRangeException</a></code></h4>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.Period" href="#yfinance_cache.yfc_dat.Period">Period</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.Period.Days1" href="#yfinance_cache.yfc_dat.Period.Days1">Days1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Days5" href="#yfinance_cache.yfc_dat.Period.Days5">Days5</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Max" href="#yfinance_cache.yfc_dat.Period.Max">Max</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Months1" href="#yfinance_cache.yfc_dat.Period.Months1">Months1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Months3" href="#yfinance_cache.yfc_dat.Period.Months3">Months3</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Months6" href="#yfinance_cache.yfc_dat.Period.Months6">Months6</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Years1" href="#yfinance_cache.yfc_dat.Period.Years1">Years1</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Years2" href="#yfinance_cache.yfc_dat.Period.Years2">Years2</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Years5" href="#yfinance_cache.yfc_dat.Period.Years5">Years5</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.Period.Ytd" href="#yfinance_cache.yfc_dat.Period.Ytd">Ytd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.ReportingPeriod" href="#yfinance_cache.yfc_dat.ReportingPeriod">ReportingPeriod</a></code></h4>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.ReportingPeriod.Full" href="#yfinance_cache.yfc_dat.ReportingPeriod.Full">Full</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.ReportingPeriod.Interim" href="#yfinance_cache.yfc_dat.ReportingPeriod.Interim">Interim</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate" href="#yfinance_cache.yfc_dat.TimedeltaEstimate">TimedeltaEstimate</a></code></h4>
<ul class="two-column">
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.copy" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.copy">copy</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.isclose" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.isclose">isclose</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_ge" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_gt" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_le" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaEstimate.prob_lt" href="#yfinance_cache.yfc_dat.TimedeltaEstimate.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.TimedeltaRange" href="#yfinance_cache.yfc_dat.TimedeltaRange">TimedeltaRange</a></code></h4>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRange.prob_ge" href="#yfinance_cache.yfc_dat.TimedeltaRange.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRange.prob_gt" href="#yfinance_cache.yfc_dat.TimedeltaRange.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRange.prob_le" href="#yfinance_cache.yfc_dat.TimedeltaRange.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRange.prob_lt" href="#yfinance_cache.yfc_dat.TimedeltaRange.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate">TimedeltaRangeEstimate</a></code></h4>
<ul class="">
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.isclose" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate.isclose">isclose</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_ge" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_ge">prob_ge</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_gt" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_gt">prob_gt</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_le" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_le">prob_le</a></code></li>
<li><code><a title="yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_lt" href="#yfinance_cache.yfc_dat.TimedeltaRangeEstimate.prob_lt">prob_lt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="yfinance_cache.yfc_dat.TimestampOutsideIntervalException" href="#yfinance_cache.yfc_dat.TimestampOutsideIntervalException">TimestampOutsideIntervalException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
